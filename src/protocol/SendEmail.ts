// **********************************************************************
// Parsed By TarsParser(3.0.4), Generated By tools(20200627)
// TarsParser Maintained By <TARS> and tools Maintained By <superzheng>
// Generated from "SendEmail.tars" by Server Mode
// **********************************************************************

/* tslint:disable */
/* eslint-disable */

/// <reference types="node" />
import assert = require("assert");
import * as TarsStream from "@tars/stream";
import * as TarsRpc from "@tars/rpc";

const _hasOwnProperty = Object.prototype.hasOwnProperty;

export namespace Base {
    export enum SendEmailRet {
        SM_SUCC = 0,
        SM_SYSTEM_ERROR = -1
    }

    export namespace SendEmailRet {
        export const _classname = "Base.SendEmailRet";
        export function _write(os: TarsStream.TarsOutputStream, tag: number, val: number) { return os.writeInt32(tag, val); }
        export function _read(is: TarsStream.TarsInputStream, tag: number, def?: number) { return is.readInt32(tag, true, def); }
    }


    export class SendInfo {
        to: TarsStream.List<string> = new TarsStream.List(TarsStream.String);
        cc: TarsStream.List<string> = new TarsStream.List(TarsStream.String);
        bcc: TarsStream.List<string> = new TarsStream.List(TarsStream.String);
        subject: string = "";

        protected _proto_struct_name_ = "";
        protected _classname = "Base.SendInfo";
        protected static _classname = "Base.SendInfo";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new SendInfo;
            tmp.to = is.readList(1, false, TarsStream.List(TarsStream.String));
            tmp.cc = is.readList(2, false, TarsStream.List(TarsStream.String));
            tmp.bcc = is.readList(3, false, TarsStream.List(TarsStream.String));
            tmp.subject = is.readString(4, false, "");
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeList(1, this.to);
            os.writeList(2, this.cc);
            os.writeList(3, this.bcc);
            os.writeString(4, this.subject);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): SendInfo.Object { 
            return {
                to: this.to.toObject(),
                cc: this.cc.toObject(),
                bcc: this.bcc.toObject(),
                subject: this.subject
            };
        }

        readFromObject(json: SendInfo.Object) { 
            _hasOwnProperty.call(json, "to") && (this.to.readFromObject(json.to!));
            _hasOwnProperty.call(json, "cc") && (this.cc.readFromObject(json.cc!));
            _hasOwnProperty.call(json, "bcc") && (this.bcc.readFromObject(json.bcc!));
            _hasOwnProperty.call(json, "subject") && (this.subject = json.subject!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new SendInfo();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Base.SendInfo._readFrom(is);
        }
    }

    export namespace SendInfo {
        export interface Object {
            to?: Array<string>;
            cc?: Array<string>;
            bcc?: Array<string>;
            subject?: string;
        }
    }

    export class ContentInfo {
        text: string = "";
        html: string = "";

        protected _proto_struct_name_ = "";
        protected _classname = "Base.ContentInfo";
        protected static _classname = "Base.ContentInfo";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new ContentInfo;
            tmp.text = is.readString(1, false, "");
            tmp.html = is.readString(2, false, "");
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeString(1, this.text);
            os.writeString(2, this.html);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): ContentInfo.Object { 
            return {
                text: this.text,
                html: this.html
            };
        }

        readFromObject(json: ContentInfo.Object) { 
            _hasOwnProperty.call(json, "text") && (this.text = json.text!);
            _hasOwnProperty.call(json, "html") && (this.html = json.html!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new ContentInfo();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Base.ContentInfo._readFrom(is);
        }
    }

    export namespace ContentInfo {
        export interface Object {
            text?: string;
            html?: string;
        }
    }

    export class MarkdownInfo {
        markdown: string = "";
        css: string = "github.css";

        protected _proto_struct_name_ = "";
        protected _classname = "Base.MarkdownInfo";
        protected static _classname = "Base.MarkdownInfo";
        protected static _write(os: TarsStream.TarsOutputStream, tag: number, val: any) { os.writeStruct(tag, val); }
        protected static _read(is: TarsStream.TarsInputStream, tag: number, def?: any) { return is.readStruct(tag, true, def); }
        protected static _readFrom(is: TarsStream.TarsInputStream) {
            const tmp = new MarkdownInfo;
            tmp.markdown = is.readString(1, false, "");
            tmp.css = is.readString(2, false, "github.css");
            return tmp;
        }

        protected _writeTo(os: TarsStream.TarsOutputStream) {
            os.writeString(1, this.markdown);
            os.writeString(2, this.css);
        }

        protected _equal() {
            assert.fail("this structure not define key operation");
        }

        protected _genKey() {
            if (!this._proto_struct_name_) {
                this._proto_struct_name_ = "STRUCT" + Math.random();
            }
            return this._proto_struct_name_;
        }

        toObject(): MarkdownInfo.Object { 
            return {
                markdown: this.markdown,
                css: this.css
            };
        }

        readFromObject(json: MarkdownInfo.Object) { 
            _hasOwnProperty.call(json, "markdown") && (this.markdown = json.markdown!);
            _hasOwnProperty.call(json, "css") && (this.css = json.css!);
            return this;
        }

        toBinBuffer() {
            const os = new TarsStream.TarsOutputStream();
            this._writeTo(os);
            return os.getBinBuffer();
        }

        static new() {
            return new MarkdownInfo();
        }

        static create(is: TarsStream.TarsInputStream) {
            return Base.MarkdownInfo._readFrom(is);
        }
    }

    export namespace MarkdownInfo {
        export interface Object {
            markdown?: string;
            css?: string;
        }
    }

    export abstract class SendEmailImp { 
        _name!: string
        _worker!: any

        initialize(): PromiseLike<any> | void {}

        onDispatch(current: TarsRpc.TarsCurrent, funcName: string, binBuffer: TarsStream.BinBuffer) { 
            if ("__" + funcName in this) {
                return (this as any)["__" + funcName](current, binBuffer);
            } else {
                return TarsRpc.error.SERVER.FUNC_NOT_FOUND;
            }
        }

        __tars_ping(current: TarsRpc.TarsCurrent) { 
            const _ret = 0;
            if (current.getRequestVersion() === TarsStream.Tup.TUP_SIMPLE || current.getRequestVersion() === TarsStream.Tup.TUP_COMPLEX) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = current.getRequestVersion();
                tup.writeInt32("", _ret);

                current.doResponse(tup.encode());
            } else {
                const os = new TarsStream.TarsOutputStream();
                os.writeInt32(0, _ret);

                current.doResponse(os.getBinBuffer());
            }

            return TarsRpc.error.SUCCESS;
        }

        sendEmail(current: SendEmailImp.sendEmailCurrent, send: Base.SendInfo, info: Base.ContentInfo): any { 
            assert.fail("sendEmail function not implemented");
        }

        protected static __sendEmail_responser(this: TarsRpc.TarsCurrent, _ret: number) {
            if (this.getRequestVersion() === TarsStream.Tup.TUP_SIMPLE || this.getRequestVersion() === TarsStream.Tup.TUP_COMPLEX) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = this.getRequestVersion();
                tup.writeInt32("", _ret);

                this.doResponse(tup.encode());
            } else if (this.getRequestVersion() === TarsStream.Tup.JSON_VERSION) {
                const _data_ = {
                    "tars_ret": _ret
                };

                this.doResponse(new TarsStream.BinBuffer(Buffer.from(JSON.stringify(_data_))));
            } else {
                const os = new TarsStream.TarsOutputStream();
                os.writeInt32(0, _ret);

                this.doResponse(os.getBinBuffer());
            }
        }

        protected __sendEmail(current: TarsRpc.TarsCurrent, binBuffer: TarsStream.BinBuffer) {
            let send: Base.SendInfo;
            let info: Base.ContentInfo;

            if (current.getRequestVersion() === TarsStream.Tup.TUP_SIMPLE || current.getRequestVersion() === TarsStream.Tup.TUP_COMPLEX) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = current.getRequestVersion();
                tup.decode(binBuffer);
                send = tup.readStruct("send", Base.SendInfo);
                info = tup.readStruct("info", Base.ContentInfo);
            } else if (current.getRequestVersion() === TarsStream.Tup.JSON_VERSION) {
                const _data_ = JSON.parse(binBuffer.toNodeBuffer().toString());
                send = new Base.SendInfo;
                send.readFromObject(_data_.send);
                info = new Base.ContentInfo;
                info.readFromObject(_data_.info);
            } else {
                const is = new TarsStream.TarsInputStream(binBuffer);
                send = is.readStruct(1, true, Base.SendInfo);
                info = is.readStruct(2, true, Base.ContentInfo);
            }

            current.sendResponse = SendEmailImp.__sendEmail_responser;

            this.sendEmail(current, send, info);

            return TarsRpc.error.SUCCESS;
        }

        sendEmailMarkdown(current: SendEmailImp.sendEmailMarkdownCurrent, send: Base.SendInfo, info: Base.MarkdownInfo): any { 
            assert.fail("sendEmailMarkdown function not implemented");
        }

        protected static __sendEmailMarkdown_responser(this: TarsRpc.TarsCurrent, _ret: number) {
            if (this.getRequestVersion() === TarsStream.Tup.TUP_SIMPLE || this.getRequestVersion() === TarsStream.Tup.TUP_COMPLEX) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = this.getRequestVersion();
                tup.writeInt32("", _ret);

                this.doResponse(tup.encode());
            } else if (this.getRequestVersion() === TarsStream.Tup.JSON_VERSION) {
                const _data_ = {
                    "tars_ret": _ret
                };

                this.doResponse(new TarsStream.BinBuffer(Buffer.from(JSON.stringify(_data_))));
            } else {
                const os = new TarsStream.TarsOutputStream();
                os.writeInt32(0, _ret);

                this.doResponse(os.getBinBuffer());
            }
        }

        protected __sendEmailMarkdown(current: TarsRpc.TarsCurrent, binBuffer: TarsStream.BinBuffer) {
            let send: Base.SendInfo;
            let info: Base.MarkdownInfo;

            if (current.getRequestVersion() === TarsStream.Tup.TUP_SIMPLE || current.getRequestVersion() === TarsStream.Tup.TUP_COMPLEX) {
                const tup = new TarsStream.UniAttribute();
                tup.tupVersion = current.getRequestVersion();
                tup.decode(binBuffer);
                send = tup.readStruct("send", Base.SendInfo);
                info = tup.readStruct("info", Base.MarkdownInfo);
            } else if (current.getRequestVersion() === TarsStream.Tup.JSON_VERSION) {
                const _data_ = JSON.parse(binBuffer.toNodeBuffer().toString());
                send = new Base.SendInfo;
                send.readFromObject(_data_.send);
                info = new Base.MarkdownInfo;
                info.readFromObject(_data_.info);
            } else {
                const is = new TarsStream.TarsInputStream(binBuffer);
                send = is.readStruct(1, true, Base.SendInfo);
                info = is.readStruct(2, true, Base.MarkdownInfo);
            }

            current.sendResponse = SendEmailImp.__sendEmailMarkdown_responser;

            this.sendEmailMarkdown(current, send, info);

            return TarsRpc.error.SUCCESS;
        }

    }

    export namespace SendEmailImp {
        export interface sendEmailCurrent extends TarsRpc.TarsCurrent {
            sendResponse(ret: number): void;
        }
        export interface sendEmailMarkdownCurrent extends TarsRpc.TarsCurrent {
            sendResponse(ret: number): void;
        }
    }

}


